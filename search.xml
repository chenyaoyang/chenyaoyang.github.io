<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Playfair密码]]></title>
    <url>%2F2019%2F03%2F20%2FPlayfair%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[背景这种加密方法是1854年Charles Wheatstone发明的，由Lord Playfair推广，所以命名为Playfair密码。它在一战和二战中都有使用，虽然在一战中就被破译，但是由于使用简单，可以用来保护一些敏感但不很关键的信息，即使被破译，信息也已经过时。 详细流程创建矩阵这种密码使用一个5*5的矩阵作为一个密码表，用作加密解密时的秘钥。这个矩阵由一个关键词生成，首先将关键词从左到右，从上到下填入矩阵，遇到重复元素则省略，写完之后按照字母表顺序，将未出现的字母填充到剩余位置，知道整个矩阵被填满。 如以PLAYFAIREXAMPLE为关键词，生成的矩阵如下： 你可能注意到，密码表中缺少J，由于只有25个空位，对于字母大于25的语言，可以将某两个合并，或者省去出现频率少的，这里把i和j进行了合并 加密加密之前首先将明文两两分组），对每一组分别进行以下处理 在密码表中找到每组中两个字母的位置 若果两个字母相同或组中只有一个字母，则插入一个字母，如X或Q（如果最后一个字母或者重复的字母是X，可以添加Q，替换方法可自定义） 如果两个字母在密码表的同一行，则用这两个字母右边的字母进行替换，如(I,E)替换为(R,X)。我们定义第一列是最后一列的右边 如果两个字母在密码表的同一列，则用这两个字母的下方字母进行替换，如(E,O)替换为(D,V)。我们定义第一行是最后一行的下边 如果两个字母不在同一行同一列，则用对角线上的字母进行替换，至于是行替换或列替换可以自行定义。如(M,Y)替换为(X,F)，使用的是行替换 示例如还以PLAYFAIREXAMPLE为关键词，明文为MYNAMEISTOM，加密过程如下： 生成矩阵，如上图 分组：MY NA ME IS TO MX (最后一个单独字母补X) 根据密码表替换 XF OL IX MK VK IM 最后密文为： XFOLIXMKVKIM 简单实现这里只是简单实现了Playfair密码原理，有些地方如包含标点符号，非英文字母的情况并没有处理，有兴趣的可以自行修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class PlayFair &#123; char[][] table = new char[5][5]; //密码表 PlayFair(String key)&#123; generateTable(key);//根据关键字生成密码表 &#125; private void generateTable(String key)&#123; key = key.replaceAll(" ","").toUpperCase(); char[] keys = key.toCharArray(); int count = 0; char alphabet = 'A'; ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (int i = 0;i&lt;5;i++)&#123; for (int j = 0;j&lt;5;j++)&#123; while(count &lt; keys.length &amp;&amp; list.contains(keys[count]))&#123; //寻找关键字中不重复的字母 count++; &#125; if (count &lt; keys.length)&#123; table[i][j] = keys[count]; list.add(keys[count]); count++; &#125;else&#123; while (alphabet &lt;= 'Z' &amp;&amp; (list.contains(alphabet) || alphabet == 'J'))&#123; //按顺序从字母表中填充 alphabet++; &#125; table[i][j] = alphabet; alphabet++; &#125; &#125; &#125; &#125; public String encryption(String msg)&#123; //加密算法 msg = msg.replaceAll(" ","").toUpperCase(); char[] msgs = msg.toCharArray(); StringBuffer result = new StringBuffer(); for (int i = 0;i&lt;msgs.length;i++)&#123; char a = msgs[i];//获取分组第一个字母 i++; char b; if (i&lt;msgs.length)&#123; //判读是否越界 if (msgs[i] == a)&#123; //是否重复 if (a == 'X')&#123; //若是X重复，添加Q b = 'Q'; &#125;else&#123; b = 'X'; &#125; i--; &#125;else&#123; b = msgs[i]; &#125; &#125;else&#123; //越界，就是最后只剩一个字母 if (a == 'X')&#123; //若最后一个是X，补Q b = 'Q'; &#125;else&#123; b = 'X'; &#125; &#125; int[] locA = find(a); //寻找分组第一个字母位置 int[] locB = find(b); //寻找分组第二个字母位置 if(locA[0] == locB[0])&#123; //若在同一行 a = locA[1]+1&lt;5?table[locA[0]][locA[1]+1]:table[locA[0]][0]; b = locB[1]+1&lt;5?table[locB[0]][locB[1]+1]:table[locB[0]][0]; &#125;else if(locA[1] == locB[1])&#123; //若在同一列 a = locA[0]+1&lt;5?table[locA[0]+1][locA[1]]:table[0][locA[1]]; b = locB[0]+1&lt;5?table[locB[0]+1][locB[1]]:table[0][locB[1]]; &#125;else&#123; //不在同一行同一列，行替换 a = table[locA[0]][locB[1]]; b = table[locB[0]][locA[1]]; &#125; result.append(a); result.append(b); &#125; return result.toString(); &#125; public String decrypt(String msg)&#123; //解密算法 msg = msg.replaceAll(" ","").toUpperCase(); char[] msgs = msg.toCharArray(); if (msgs.length%2!=0)&#123; //密文不是偶数个，报错 return "error: The length of ciphertext is odd"; &#125; StringBuffer result = new StringBuffer(); for (int i = 0;i&lt;msgs.length;i++)&#123; char a = msgs[i]; i++; char b = msgs[i]; int[] locA = find(a);//寻找分组第一个字母位置 int[] locB = find(b);//寻找分组第二个字母位置 if(locA[0] == locB[0])&#123; //若在同一行 a = locA[1]-1&gt;-1?table[locA[0]][locA[1]-1]:table[locA[0]][4]; b = locB[1]-1&gt;-1?table[locB[0]][locB[1]-1]:table[locB[0]][4]; &#125;else if(locA[1] == locB[1])&#123; //若在同一列 a = locA[0]-1&gt;-1?table[locA[0]-1][locA[1]]:table[4][locA[1]]; b = locB[0]-1&gt;-1?table[locB[0]-1][locB[1]]:table[4][locB[1]]; &#125;else&#123; //不在同一行同一列 a = table[locA[0]][locB[1]]; b = table[locB[0]][locA[1]]; &#125; result.append(a); result.append(b); &#125; return result.toString(); &#125; private int[] find(char c)&#123; //寻找字母在表中位置 if (c == 'J')//对于J当做I处理 c = 'I'; for (int i = 0;i&lt;5;i++)&#123; for (int j = 0;j&lt;5;j++)&#123; if (table[i][j] == c) return new int[]&#123;i,j&#125;; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125; public static void main(String[] args) &#123;//测试代码 PlayFair p = new PlayFair("PLAYFAIREXAMPLE"); String msg = p.encryption("MYNAMEISTOM"); System.out.println("ciphertext：" + msg); System.out.println("plaintext：" + p.decrypt(msg)); &#125;&#125; 小结本质上Playfair密码仍然是替换型的密码算法。与一般的替换算法相比，他的替换不固定，每个字母都有可能替换为任意一个其他字母。另外实现简单，一个不同秘钥生成不同密码表，产生不同的替换可能。但是它依然可以被破解，首先它是按照顺序读取的，密文与明文基本上一一对应，从而也暴露的密文结构；其次，密码表最后填充时是按照字母表顺序填充，可借助字母出现频率构造密码表，一旦一部分被构造出来，剩下的很容易破解；]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rlp编码学习]]></title>
    <url>%2F2019%2F03%2F19%2Frlp%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[RLP的全称是Recursive Length Prefix，是以太坊实现中普遍使用的一种序列化方法，在黄皮书的附录B中有详细的定义，我们这里也简要学习一下 源数据RLP定义了两种源数据，一种是一维的字节数组；另外一种是多维字节数组，也就是一维数组的嵌套。所有要序列化的数据类型，都要有一定的方法转为上述两种格式，转换的方法可以根据不同的实现自己定义。在黄皮书中给出了源数据的定义： RLP定义函数定义如下： 可见分别定义了两个函数，对应了上一节中的两种源数据，分别解释一下这两个函数 源数据为一维字节数组当数据为简单的一维字节数组时，有以下三种序列化规则: 当只含有一个字节时，而且这个字节又小于128，则不做任何处理，直接输出，对应上图第一种情况 当字节数组的长度小于56时，则加上一个前缀，这个前缀等于128+字节数组长度，对应上图第二种情况 若不符合上述两种情况，则加上这样两个前缀，第一个前缀等于183+字节数组长度在大端表示时的长度，第二个前缀为字节数组长度的大端表示，对应上图第三种情况（所谓大端表示就是将高位字节排放在内存的低地址端，0x1234表示为00 00 12 34，BE函数就是去除前面的零，也可以理解为实际长度） 源数据为嵌套的多维字节数组当数据为嵌套的多维数组形式时，有以下两种序列化规则： 首先对数组中每一个子元素都递归使用上一小节中的规则序列化，注意序列化时对象都要为一维字节数组，若子元素也是嵌套格式，则递归调用，之后将每个子元素序列化结果拼接起来。对于拼接后的长度： 若长度小于56，则加上这样一个前缀，这个前缀等于192+拼接后的长度，对应上图第一种情况 若长度大于等于56，则加上这样两个前缀，第一个前缀等于247+拼接后字节数组长度在大端表示时的长度，第二个前缀为拼接后的长度的大端表示，对应上图第二种情况 源数据是标量数据首先RLP只能用于处理正整数，处理是要先用BE函数处理，去掉前导0后，当做字节数组处理，如下图： 解码实际上了解到编码规则后，解码就很简单，关键就是第一个字节，这个字节标识使用哪种情况编码 当位于[0,128)区间时，对应源数据是一维字节数组的第一种情况，就是单一字节 当位于[128,184)区间时，对应源数据是一维字节数组的第二种情况，就是长度小于56的一维字节数组 当位于[184,192)区间时，对应源数据是一维字节数组的第三种情况，这时观察第二个前缀，第二个前缀长度等于第一个字节减去183，然后计算原始数据的真正长度 当位于[192,247)区间时，对于源数据是多维字节数组的第一种情况，就是拼接长度小于56，递归解析其后数据 当位于[247,256)区间时，对于源数据是多维字节数组的第二种情况，类似于第三条规则，先实际计算出第二个前缀的长度，在解析数原始数据长度，在递归解析出原始数据 源码解析源码主要集中在go-ethereum\rlp目录下，再去除一些测试代码，实际功能代码并不多，关键如下：1234decode.go //解码器，就是反序列化encode.go //编码器，就是序列化raw.go //未解码的RLP数据typecache.go //类型缓存， 类型缓存记录了类型-&gt;(编码器|解码器)的内容。 typecache由于go-ethereum是用go语言实现的，而go语言没有方法重载，所以对于不同类型的数据要手动指定需要的编解码器。这个类主要功能是给我们返回一个typeinfo类型的对象，这个对象保存在对应数据类型的编解码方法1234type typeinfo struct &#123; decoder writer&#125; 去创建一个typeinfo需要从cachedTypeInfo方法开始：1234567891011121314151617181920212223242526272829303132333435363738// go-ethereum\rlp\typecache.gofunc cachedTypeInfo(typ reflect.Type, tags tags) (*typeinfo, error) &#123; typeCacheMutex.RLock() info := typeCache[typekey&#123;typ, tags&#125;] //尝试从缓存中国区 typeCacheMutex.RUnlock() if info != nil &#123; //获取成功 return info, nil &#125; typeCacheMutex.Lock() //加锁，避免多线程多次创建 defer typeCacheMutex.Unlock() return cachedTypeInfo1(typ, tags)&#125;func cachedTypeInfo1(typ reflect.Type, tags tags) (*typeinfo, error) &#123; key := typekey&#123;typ, tags&#125; info := typeCache[key]//再次尝试获取，确保只创建一次 if info != nil &#123; //获取成功 return info, nil &#125; typeCache[key] = new(typeinfo) //创建一个空对象 info, err := genTypeInfo(typ, tags) //实际创建对象 if err != nil &#123; //创建失败 delete(typeCache, key) return nil, err &#125; *typeCache[key] = *info //存储到map中 return typeCache[key], err&#125;func genTypeInfo(typ reflect.Type, tags tags) (info *typeinfo, err error) &#123; info = new(typeinfo) if info.decoder, err = makeDecoder(typ, tags); err != nil &#123; return nil, err &#125; if info.writer, err = makeWriter(typ, tags); err != nil &#123; return nil, err &#125; return info, nil&#125; 可见对每种类型，都是单例模式。上述代码中实际创建编解码器的方法是makeDecoder和makeWriter。这两个方法详见下文 encode对于编码器的使用，一般调用Encode函数：123456789101112func Encode(w io.Writer, val interface&#123;&#125;) error &#123; if outer, ok := w.(*encbuf); ok &#123;//判断是否是encbuf类型的writer return outer.encode(val) &#125; eb := encbufPool.Get().(*encbuf) //从并发变量池中获取一个encbuf对象 defer encbufPool.Put(eb) eb.reset() //清空原有数据 if err := eb.encode(val); err != nil &#123; //编码 return err &#125; return eb.toWriter(w)&#125; 编码的核心操作在encbuf的encode方法：12345678func (w *encbuf) encode(val interface&#123;&#125;) error &#123; rval := reflect.ValueOf(val) ti, err := cachedTypeInfo(rval.Type(), tags&#123;&#125;) if err != nil &#123; return err &#125; return ti.writer(rval, w)&#125; 这里就接上了上一节typecache中的方法，这里通过makeWriter确定编码器1234567891011121314151617181920212223242526272829303132333435func makeWriter(typ reflect.Type, ts tags) (writer, error) &#123; kind := typ.Kind() switch &#123; case typ == rawValueType: return writeRawValue, nil case typ.Implements(encoderInterface): return writeEncoder, nil case kind != reflect.Ptr &amp;&amp; reflect.PtrTo(typ).Implements(encoderInterface): return writeEncoderNoPtr, nil case kind == reflect.Interface: return writeInterface, nil case typ.AssignableTo(reflect.PtrTo(bigInt)): return writeBigIntPtr, nil case typ.AssignableTo(bigInt): return writeBigIntNoPtr, nil case isUint(kind): return writeUint, nil case kind == reflect.Bool: return writeBool, nil case kind == reflect.String: return writeString, nil case kind == reflect.Slice &amp;&amp; isByte(typ.Elem()): return writeBytes, nil case kind == reflect.Array &amp;&amp; isByte(typ.Elem()): return writeByteArray, nil case kind == reflect.Slice || kind == reflect.Array: return makeSliceWriter(typ, ts) case kind == reflect.Struct: return makeStructWriter(typ) case kind == reflect.Ptr: return makePtrWriter(typ) default: return nil, fmt.Errorf("rlp: type %v is not RLP-serializable", typ) &#125;&#125; 就是简单的根据不同的类型创建不同的编码方法，以string为例：1234567891011121314151617181920func writeString(val reflect.Value, w *encbuf) error &#123; s := val.String() if len(s) == 1 &amp;&amp; s[0] &lt;= 0x7f &#123;//只有一个字符，且小于128 w.str = append(w.str, s[0]) &#125; else &#123; w.encodeStringHeader(len(s))//添加前缀 w.str = append(w.str, s...) &#125; return nil&#125;func (w *encbuf) encodeStringHeader(size int) &#123; if size &lt; 56 &#123; //长度小于56 w.str = append(w.str, 0x80+byte(size))//前缀是128+长度 &#125; else &#123; //其他情况 sizesize := putint(w.sizebuf[1:], uint64(size)) //将长度的大端表示写入sizebuf w.sizebuf[0] = 0xB7 + byte(sizesize) //第一个前缀183+字符串长度在大端表示后的长度 w.str = append(w.str, w.sizebuf[:sizesize+1]...)//拼接第二个前缀，字符串长度的大端表示 &#125;&#125; 详细过程见注释，基本过程和RLP定义的一样。对于结构体可能有些特殊：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func makeStructWriter(typ reflect.Type) (writer, error) &#123; fields, err := structFields(typ) //分析结构体每个字段，根据情况指定每个字段的编码方法 if err != nil &#123; return nil, err &#125; writer := func(val reflect.Value, w *encbuf) error &#123; //编码器具体方法 lh := w.list() for _, f := range fields &#123; if err := f.info.writer(val.Field(f.index), w); err != nil &#123; return err &#125; &#125; w.listEnd(lh) return nil &#125; return writer, nil&#125;// go-ethereum\rlp\typecache.gofunc structFields(typ reflect.Type) (fields []field, err error) &#123; for i := 0; i &lt; typ.NumField(); i++ &#123; if f := typ.Field(i); f.PkgPath == "" &#123; // 若果是可导出的，也就是首字母大写，PkgPath为空，不可导出会返回包名 tags, err := parseStructTag(typ, i)//解析每个字段的标签，就是字段后``中定义的 if err != nil &#123; return nil, err &#125; if tags.ignored &#123; continue &#125; info, err := cachedTypeInfo1(f.Type, tags)//根据类型获取cachedTypeInfo，包含编解码器 if err != nil &#123; return nil, err &#125; fields = append(fields, field&#123;i, info&#125;) &#125; &#125; return fields, nil&#125;func parseStructTag(typ reflect.Type, fi int) (tags, error) &#123; f := typ.Field(fi) var ts tags for _, t := range strings.Split(f.Tag.Get("rlp"), ",") &#123; switch t = strings.TrimSpace(t); t &#123; case "": case "-": ts.ignored = true case "nil": ts.nilOK = true case "tail": ts.tail = true if fi != typ.NumField()-1 &#123; return ts, fmt.Errorf(`rlp: invalid struct tag "tail" for %v.%s (must be on last field)`, typ, f.Name) &#125; if f.Type.Kind() != reflect.Slice &#123; return ts, fmt.Errorf(`rlp: invalid struct tag "tail" for %v.%s (field type is not slice)`, typ, f.Name) &#125; default: return ts, fmt.Errorf("rlp: unknown struct tag %q on %v.%s", t, typ, f.Name) &#125; &#125; return ts, nil&#125; 结构体类型的虽然复杂，但也是具体到每个字段执行不同的序列化方法，最后进行拼接。 decode对于解码器一般调用Decode函数：1234567891011121314151617181920212223242526func Decode(r io.Reader, val interface&#123;&#125;) error &#123; return NewStream(r, 0).Decode(val)&#125;func (s *Stream) Decode(val interface&#123;&#125;) error &#123; if val == nil &#123; return errDecodeIntoNil &#125; rval := reflect.ValueOf(val) rtyp := rval.Type() if rtyp.Kind() != reflect.Ptr &#123; //判断是否为指针类型 return errNoPointer &#125; if rval.IsNil() &#123; return errDecodeIntoNil &#125; info, err := cachedTypeInfo(rtyp.Elem(), tags&#123;&#125;) //获取编解码方法 if err != nil &#123; return err &#125; err = info.decoder(s, rval.Elem())//解码 if decErr, ok := err.(*decodeError); ok &amp;&amp; len(decErr.ctx) &gt; 0 &#123; decErr.ctx = append(decErr.ctx, fmt.Sprint("(", rtyp.Elem(), ")")) &#125; return err&#125; 注意decode的逻辑是从Stream中获取源数据，最后解析到val中，所以需要val是一个指针类型，接下来又回到typecache中，通过判断val的类型获取所需的解码器。12345678910111213141516171819202122232425262728293031323334func makeDecoder(typ reflect.Type, tags tags) (dec decoder, err error) &#123; kind := typ.Kind() switch &#123; case typ == rawValueType: return decodeRawValue, nil case typ.Implements(decoderInterface): return decodeDecoder, nil case kind != reflect.Ptr &amp;&amp; reflect.PtrTo(typ).Implements(decoderInterface): return decodeDecoderNoPtr, nil case typ.AssignableTo(reflect.PtrTo(bigInt)): return decodeBigInt, nil case typ.AssignableTo(bigInt): return decodeBigIntNoPtr, nil case isUint(kind): return decodeUint, nil case kind == reflect.Bool: return decodeBool, nil case kind == reflect.String: return decodeString, nil case kind == reflect.Slice || kind == reflect.Array: return makeListDecoder(typ, tags) case kind == reflect.Struct: return makeStructDecoder(typ) case kind == reflect.Ptr: if tags.nilOK &#123; return makeOptionalPtrDecoder(typ) &#125; return makePtrDecoder(typ) case kind == reflect.Interface: return decodeInterface, nil default: return nil, fmt.Errorf("rlp: type %v is not RLP-serializable", typ) &#125;&#125; 以string为例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192func decodeString(s *Stream, val reflect.Value) error &#123; b, err := s.Bytes() if err != nil &#123; return wrapStreamError(err, val.Type()) &#125; val.SetString(string(b)) //还原为string return nil&#125;func (s *Stream) Bytes() ([]byte, error) &#123; kind, size, err := s.Kind() if err != nil &#123; return nil, err &#125; switch kind &#123; case Byte: s.kind = -1 return []byte&#123;s.byteval&#125;, nil case String: b := make([]byte, size) //根据数据长度指定byte数组 if err = s.readFull(b); err != nil &#123; //读取原始数据 return nil, err &#125; if size == 1 &amp;&amp; b[0] &lt; 128 &#123; return nil, ErrCanonSize &#125; return b, nil default: return nil, ErrExpectedString &#125;&#125;func (s *Stream) Kind() (kind Kind, size uint64, err error) &#123; var tos *listpos if len(s.stack) &gt; 0 &#123; tos = &amp;s.stack[len(s.stack)-1] &#125; if s.kind &lt; 0 &#123; s.kinderr = nil if tos != nil &amp;&amp; tos.pos == tos.size &#123; return 0, 0, EOL &#125; s.kind, s.size, s.kinderr = s.readKind() //读取原始数据类型以及长度 if s.kinderr == nil &#123; if tos == nil &#123; if s.limited &amp;&amp; s.size &gt; s.remaining &#123; s.kinderr = ErrValueTooLarge &#125; &#125; else &#123; if s.size &gt; tos.size-tos.pos &#123; s.kinderr = ErrElemTooLarge &#125; &#125; &#125; &#125; return s.kind, s.size, s.kinderr&#125;func (s *Stream) readKind() (kind Kind, size uint64, err error) &#123; b, err := s.readByte() //读第一个byte if err != nil &#123; if len(s.stack) == 0 &#123; switch err &#123; case io.ErrUnexpectedEOF: err = io.EOF case ErrValueTooLarge: err = io.EOF &#125; &#125; return 0, 0, err &#125; s.byteval = 0 switch &#123; //根据第一字节的只判断原始数据类型 case b &lt; 0x80: //原始数据只有一个byte，且小于128 s.byteval = b return Byte, 0, nil case b &lt; 0xB8: //原始数据长度小于56 //返回的第二个数据获得原始数据长度 return String, uint64(b - 0x80), nil case b &lt; 0xC0: size, err = s.readUint(b - 0xB7) if err == nil &amp;&amp; size &lt; 56 &#123; err = ErrCanonSize &#125; return String, size, err case b &lt; 0xF8: return List, uint64(b - 0xC0), nil default: size, err = s.readUint(b - 0xF7) if err == nil &amp;&amp; size &lt; 56 &#123; err = ErrCanonSize &#125; return List, size, err &#125;&#125; 可见流程就是rlp编码的逆向过程，和我们之前讲的解码方法一样，关键是通过第一个字节获取原始数据的类型，然后推算出原始数据的长度，最后解析即可 小结最后，go-ethereum源码中rlp实现部分还是很完整的，并且没有什么其他依赖，都使用的是go标准包，所以可以单独拿出来做一个库，以后遇到需要用rlp编码的地方，可以直接拿来使用。还有这一部分源码大量的使用了反射，对于学习go语言反射也是很好的一个素材]]></content>
      <categories>
        <category>go-ethereum源码学习</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>以太坊</tag>
        <tag>go-ethereum</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言signal包使用指南]]></title>
    <url>%2F2019%2F02%2F27%2FGo%E8%AF%AD%E8%A8%80signal%E5%8C%85%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[go语言学习笔记：signal包 os/signal主要用于实现对信号的处理(官方文档) 信号类型首先关于linux信号机制课自行查找资料，这里不再赘述。linux中的全部信号如下图： 在go中预定义了几种信号：1234567891011121314151617//"syscall"const ( // More invented values for signals SIGHUP = Signal(0x1) SIGINT = Signal(0x2) SIGQUIT = Signal(0x3) SIGILL = Signal(0x4) SIGTRAP = Signal(0x5) SIGABRT = Signal(0x6) SIGBUS = Signal(0x7) SIGFPE = Signal(0x8) SIGKILL = Signal(0x9) SIGSEGV = Signal(0xb) SIGPIPE = Signal(0xd) SIGALRM = Signal(0xe) SIGTERM = Signal(0xf)) 首先在这么多信号中，SIGKILL和SIGSTOP是无法被程序捕获的，其中SIGKILL就是我们常用的kill -9 pid方法锁触发的。其次一些有程序执行中的错误所触发的同步信号如SIGBUS，SIGFPE和SIGSEGV，go会将其转为panic，不过若是我们通过kill方式触发也是可以被捕获的。 除了那些同步信号，其余都是异步信号，是由内核或其他程序发送的，我们都可以捕获。 在异步信号中，当程序丢失终端时收到SIGHUP，在终端按下中断字符(一般为ctrl+c)时收到SIGINT，在终端按下退出字符(一般为^\)时收到SIGQUIT。 正常的，信号都是有默认动作的，最常见的如按下ctrl+c退出程序。其余的SIGHUP，SIGINT或SIGTERM信号导致程序退出。SIGQUIT，SIGILL，SIGTRAP，SIGABRT，SIGSTKFLT，SIGEMT或SIGSYS信号导致程序以堆栈转储退出。SIGTSTP，SIGTTIN或SIGTTOU信号获取系统默认行为（shell使用这些信号进行作业控制）。SIGPROF会被go运行时捕获实现runtime.CPUProfile. 捕获信号signal包中提供了Notify方法，用于注册所要监听的信号。1func Notify(c chan&lt;- os.Signal, sig ...os.Signal) 该方法需要提供一个Signal类型的channel，以及要监听的信号(当不指定时会监听所有信号)。当有信号到来时，会被写入所传入的channel中，之后拿出来即可。下例是一个监听ctrl+c退出的程序：1234567func main() &#123; c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGINT) s := &lt;-c fmt.Println("Got signal:", s)&#125; 上述程序会在第五行阻塞，直到有一个信号过来。运行结果如下： 其余apifunc Stop(c chan&lt;- os.Signal)这个方法用于停止监听信号，之后不会再往所指定的channel中写入任何内容。搭配Notify使用如下：12345678go func() &#123; sigc := make(chan os.Signal, 1) signal.Notify(sigc, syscall.SIGINT, syscall.SIGTERM) //监听信号 defer signal.Stop(sigc) //确保关闭 &lt;-sigc //线程阻塞 log.Info("Got interrupt, shutting down...") go Stop() //执行程序停止逻辑 &#125;() func Ignore(sig …os.Signal)忽略指定的信号，同理，若是未指定，忽略所有信号 func Ignored(sig os.Signal) bool检查某个信号是否被忽略 func Reset(sig …os.Signal)重置之前调用Notify时的处理。也就是不在捕获信号，进行默认操作。注意和Ignore的区别，Ignore是不对信号做任何操作，Reset是恢复默认操作。 附录部分信号说明(图片来源于网络)：]]></content>
      <categories>
        <category>go语言学习笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[geth的init流程分析]]></title>
    <url>%2F2019%2F02%2F26%2Fgeth%E7%9A%84init%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[go-ethereum源码学习：init流程 geth总览首先看一下geth这个程序的总体设计，其主要代码位于go-ethereum\cmd\geth里面，先看main.go,这是一个利用urfave/cli开发的命令行程序，关于这个库的简单介绍见这里。在开头var代码块中中实例化了cli的app对象:1234567891011121314app = utils.NewApp(gitCommit, "the go-ethereum command line interface")func NewApp(gitCommit, usage string) *cli.App &#123; app := cli.NewApp() app.Name = filepath.Base(os.Args[0]) app.Author = "" //app.Authors = nil app.Email = "" app.Version = params.VersionWithMeta //见go-ethereum\params\version.go 生成版本号 if len(gitCommit) &gt;= 8 &#123; app.Version += "-" + gitCommit[:8] //gitCommit之前在编译时定义 &#125; app.Usage = usage return app&#125; 实例化之后，定义了大量flag，详细信息可以输入geth -h或到官方文档查看。接下来，在init()方法中进行进一步初始化，添加了大量command及先前定义的flag。并定义了geth的action：1234567891011app.Action = gethfunc geth(ctx *cli.Context) error &#123; if args := ctx.Args(); len(args) &gt; 0 &#123; //仅执行geth时，不能有任何附加参数 return fmt.Errorf("invalid command: %q", args[0]) &#125; node := makeFullNode(ctx) //创建默认节点 defer node.Close() startNode(ctx, node) node.Wait() return nil&#125; 在init中还定义了app.Before用于初始化工作：123456789101112131415161718192021222324252627282930313233app.Before = func(ctx *cli.Context) error &#123; logdir := "" if ctx.GlobalBool(utils.DashboardEnabledFlag.Name) &#123; logdir = (&amp;node.Config&#123;DataDir: utils.MakeDataDir(ctx)&#125;).ResolvePath("logs") &#125; if err := debug.Setup(ctx, logdir); err != nil &#123; //见\go-ethereum\internal\debug\flags.go return err &#125; // Cap the cache allowance and tune the garbage collector var mem gosigar.Mem //见\go-ethereum\vendor\github.com\elastic\gosigar\sigar_interface.go //获取系统内存信息 if err := mem.Get(); err == nil &#123; //配置缓存 allowance := int(mem.Total / 1024 / 1024 / 3) if cache := ctx.GlobalInt(utils.CacheFlag.Name); cache &gt; allowance &#123; log.Warn("Sanitizing cache to Go's GC limits", "provided", cache, "updated", allowance) ctx.GlobalSet(utils.CacheFlag.Name, strconv.Itoa(allowance)) &#125; &#125; // Ensure Go's GC ignores the database cache for trigger percentage cache := ctx.GlobalInt(utils.CacheFlag.Name) gogc := math.Max(20, math.Min(100, 100/(float64(cache)/1024))) log.Debug("Sanitizing Go's GC trigger", "percent", int(gogc)) godebug.SetGCPercent(int(gogc)) //设置垃圾收集目标百分比 // Start metrics export if enabled utils.SetupMetrics(ctx) //默认是关闭的，开关在\go-ethereum\metrics\metrics.go // Start system runtime metrics collection go metrics.CollectProcessMetrics(3 * time.Second) //默认不会启动 return nil &#125; 随后也定义了app.After逻辑12345app.After = func(ctx *cli.Context) error &#123; debug.Exit() console.Stdin.Close() // 重置终端模式 return nil &#125; 接下来进入main函数123456func main() &#123; if err := app.Run(os.Args); err != nil &#123; //运行处理程序 fmt.Fprintln(os.Stderr, err) os.Exit(1) &#125;&#125; 到这里，geth大致轮廓就看完了，随后会根据用户输入的命令执行相应的逻辑。 init这是初始化函数。源码中描述如下 The init command initializes a new genesis block and definition for the network.This is a destructive action and changes the network in which you will beparticipating.It expects the genesis file as argument. 一般使用如下1geth init gen.json --datadir ./mychain/ 需要指定一个json文件，可选择指定数据存储路径。在源码定义如下：123456789101112// go-ethereum\cmd\geth\chaincmd.goinitCommand = cli.Command&#123; Action: utils.MigrateFlags(initGenesis), Name: "init", Usage: "Bootstrap and initialize a new genesis block", ArgsUsage: "&lt;genesisPath&gt;", Flags: []cli.Flag&#123; utils.DataDirFlag, &#125;, Category: "BLOCKCHAIN COMMANDS", Description: `.....`, &#125; 可见子命令名就是init，没有别名，只有一个flag，定义如下1234567// go-ethereum\cmd\utils\flags.goDataDirFlag = DirectoryFlag&#123; Name: "datadir", Usage: "Data directory for the databases and keystore", Value: DirectoryString&#123;node.DefaultDataDir()&#125;, //获取默认目录，见go-ethereum\node\defaults.go //linux下为/home/&lt;user&gt;/.ethereum &#125; DirectoryString定义如下123456789101112131415161718192021// go-ethereum\cmd\utils\customflags.gotype DirectoryString struct &#123; Value string&#125;func (self *DirectoryString) String() string &#123; return self.Value&#125;func (self *DirectoryString) Set(value string) error &#123; self.Value = expandPath(value) return nil&#125;func expandPath(p string) string &#123; if strings.HasPrefix(p, &quot;~/&quot;) || strings.HasPrefix(p, &quot;~\\&quot;) &#123; if home := homeDir(); home != &quot;&quot; &#123; p = home + p[1:] &#125; &#125; return path.Clean(os.ExpandEnv(p))&#125; DataDirFlag作用主要就是定义初始化生成数据的存储路径，之后我们看initCommand的action，这个是关键：1Action: utils.MigrateFlags(initGenesis), 调用了utils.MigrateFlags，定义如下1234567891011// \go-ethereum\cmd\utils\flags.gofunc MigrateFlags(action func(ctx *cli.Context) error) func(*cli.Context) error &#123; return func(ctx *cli.Context) error &#123; for _, name := range ctx.FlagNames() &#123; if ctx.IsSet(name) &#123; ctx.GlobalSet(name, ctx.String(name)) &#125; &#125; return action(ctx) &#125;&#125; 这个方法并没有什么实际意义，只是将所有用户指定的flag以GlobalSet的形式存了起来，主要逻辑在传递进来的action，我们这里传递的action如下：12345678910111213141516171819202122232425262728293031323334// go-ethereum\cmd\geth\chaincmd.gofunc initGenesis(ctx *cli.Context) error &#123; // Make sure we have a valid genesis JSON genesisPath := ctx.Args().First() //获取genesis.json if len(genesisPath) == 0 &#123; utils.Fatalf("Must supply path to genesis JSON file") &#125; file, err := os.Open(genesisPath) if err != nil &#123; utils.Fatalf("Failed to read genesis file: %v", err) &#125; defer file.Close() genesis := new(core.Genesis) //Genesis结构体见 go-ethereum\core\genesis.go if err := json.NewDecoder(file).Decode(genesis); err != nil &#123; //解析json文件，遇到错误就退出 utils.Fatalf("invalid genesis file: %v", err) &#125; // Open an initialise both full and light databases stack := makeFullNode(ctx) //建立默认节点 defer stack.Close() for _, name := range []string&#123;"chaindata", "lightchaindata"&#125; &#123; chaindb, err := stack.OpenDatabase(name, 0, 0) //创建数据库 if err != nil &#123; utils.Fatalf("Failed to open database: %v", err) &#125; _, hash, err := core.SetupGenesisBlock(chaindb, genesis) //写创世区块内容 if err != nil &#123; utils.Fatalf("Failed to write genesis block: %v", err) &#125; log.Info("Successfully wrote genesis state", "database", name, "hash", hash) &#125; return nil&#125; 刚开始，获取了子命令参数，也就是我们指定的genesis.json的文件，然后尝试打开并解析其中内容，任何一步出错的就终止程序，之后调用了stack := makeFullNode(ctx)，这一部分比较繁琐，实现如下1234567891011121314151617181920212223242526272829303132333435363738394041424344// go-ethereum\cmd\geth\config.gofunc makeFullNode(ctx *cli.Context) *node.Node &#123; stack, cfg := makeConfigNode(ctx) if ctx.GlobalIsSet(utils.ConstantinopleOverrideFlag.Name) &#123; cfg.Eth.ConstantinopleOverride = new(big.Int).SetUint64(ctx.GlobalUint64(utils.ConstantinopleOverrideFlag.Name)) &#125; utils.RegisterEthService(stack, &amp;cfg.Eth) //注册eth服务， eth服务是以太坊的主要的服务。是以太坊功能的提供者。 if ctx.GlobalBool(utils.DashboardEnabledFlag.Name) &#123; //默认是false utils.RegisterDashboardService(stack, &amp;cfg.Dashboard, gitCommit) &#125; // Whisper must be explicitly enabled by specifying at least 1 whisper flag or in dev mode //Whisper是一个独立模块，用来进行加密通讯的功能。 需要显式的提供参数来启用，或者是处于开发模式。 shhEnabled := enableWhisper(ctx) //自动启动的条件没有手动配置Whisper并且处于开发者模式 shhAutoEnabled := !ctx.GlobalIsSet(utils.WhisperEnabledFlag.Name) &amp;&amp; ctx.GlobalIsSet(utils.DeveloperFlag.Name) //二者满足一个就启动（注册shh服务）,一般都不满足 if shhEnabled || shhAutoEnabled &#123; if ctx.GlobalIsSet(utils.WhisperMaxMessageSizeFlag.Name) &#123; cfg.Shh.MaxMessageSize = uint32(ctx.Int(utils.WhisperMaxMessageSizeFlag.Name)) &#125; if ctx.GlobalIsSet(utils.WhisperMinPOWFlag.Name) &#123; cfg.Shh.MinimumAcceptedPOW = ctx.Float64(utils.WhisperMinPOWFlag.Name) &#125; if ctx.GlobalIsSet(utils.WhisperRestrictConnectionBetweenLightClientsFlag.Name) &#123; cfg.Shh.RestrictConnectionBetweenLightClients = true &#125; utils.RegisterShhService(stack, &amp;cfg.Shh) &#125; // Configure GraphQL if required if ctx.GlobalIsSet(utils.GraphQLEnabledFlag.Name) &#123; if err := graphql.RegisterGraphQLService(stack, cfg.Node.GraphQLEndpoint(), cfg.Node.GraphQLCors, cfg.Node.GraphQLVirtualHosts, cfg.Node.HTTPTimeouts); err != nil &#123; utils.Fatalf("Failed to register the Ethereum service: %v", err) &#125; &#125; // Add the Ethereum Stats daemon if requested. if cfg.Ethstats.URL != "" &#123; utils.RegisterEthStatsService(stack, cfg.Ethstats.URL) &#125; return stack&#125; 第一行调用了makeConfigNode，实现如下1234567891011121314151617181920212223242526272829303132333435363738// go-ethereum\cmd\geth\config.gofunc makeConfigNode(ctx *cli.Context) (*node.Node, gethConfig) &#123; // Load defaults. //加载各个模块的默认配置 cfg := gethConfig&#123; Eth: eth.DefaultConfig, // go-ethereum\eth\config.go //Ethereum主网的默认配置，如NetworkId，SyncMode等 Shh: whisper.DefaultConfig, // go-ethereum\whisper\whisperv6\config.go Node: defaultNodeConfig(), //见defaultNodeConfig()，默认节点配置 Dashboard: dashboard.DefaultConfig, //一个独立模块，见go-ethereum\dashboard\README &#125; // Load config file. //加载配置文件，一般未指定配置文件，此处为空 if file := ctx.GlobalString(configFileFlag.Name); file != "" &#123; if err := loadConfig(file, &amp;cfg); err != nil &#123; utils.Fatalf("%v", err) &#125; &#125; // Apply flags. //从flag加载配置 utils.SetULC(ctx, &amp;cfg.Eth) //ULC:Ultra Light client go-ethereum\cmd\utils\flags.go utils.SetNodeConfig(ctx, &amp;cfg.Node) stack, err := node.New(&amp;cfg.Node) //实例化node对象 go-ethereum\node\node.go //stack就是Node对象 if err != nil &#123; utils.Fatalf("Failed to create the protocol stack: %v", err) &#125; utils.SetEthConfig(ctx, stack, &amp;cfg.Eth) if ctx.GlobalIsSet(utils.EthStatsURLFlag.Name) &#123; cfg.Ethstats.URL = ctx.GlobalString(utils.EthStatsURLFlag.Name) &#125; utils.SetShhConfig(ctx, stack, &amp;cfg.Shh) utils.SetDashboardConfig(ctx, &amp;cfg.Dashboard) return stack, cfg&#125; 这个方法首先加载代码中的默认配置，之后加载配置文件配置，随后加载用户在命令行指定的配置，由于我们分析的是init流程，所以大部分配置都是默认配置，相关代码注释见这里代码注释 经过makeConfigNode之后，我们获得stack, cfg，stack是一个node对象，cfg是配置信息。回到makeFullNode，初始化node后，又调用了utils.RegisterEthService(stack, &amp;cfg.Eth)取注册eth服务，eth服务是以太坊功能的主要服务提供者：12345678910111213141516171819202122// go-ethereum\cmd\utils\flags.gofunc RegisterEthService(stack *node.Node, cfg *eth.Config) &#123; var err error //默认是FastSync if cfg.SyncMode == downloader.LightSync &#123; err = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) &#123; return les.New(ctx, cfg) &#125;) &#125; else &#123; err = stack.Register(func(ctx *node.ServiceContext) (node.Service, error) &#123; fullNode, err := eth.New(ctx, cfg) if fullNode != nil &amp;&amp; cfg.LightServ &gt; 0 &#123; ls, _ := les.NewLesServer(fullNode, cfg) fullNode.AddLesServer(ls) &#125; return fullNode, err &#125;) &#125; if err != nil &#123; Fatalf("Failed to register the Ethereum service: %v", err) &#125;&#125; 我们看一下Register的实现：12345678910111213// go-ethereum\node\node.gofunc (n *Node) Register(constructor ServiceConstructor) error &#123; n.lock.Lock() //同步操作 defer n.lock.Unlock() if n.server != nil &#123; return ErrNodeRunning &#125; //将ServiceConstructor添加到serviceFuncs这个切片中,ServiceConstructor定义如下 //type ServiceConstructor func(ctx *ServiceContext) (Service, error) n.serviceFuncs = append(n.serviceFuncs, constructor) return nil&#125; 逻辑很简单，就是将要注册的东西存起来。我们再来看注册的eth服务的内容。我们分析的是init的流程，默认的同步模式是FastSync，调用eth.New(ctx, cfg)，创建了一个Ethereum对象，这里我们暂不分析创建过程，只需知道这里实例化了了一个Ethereum对象，也就是变量fullNode。在回到makeConfigNode，后面就是根据具体情况去注册各种服务，如DashboardService，ShhService等，套路和eth注册是一样的。需要注意的是，这里面除了eth服务是必须的，其他的都是可选的。最后返回stack，也就是node对象 实际上，在我们分析的流程中，initGenesis调用的makeFullNode方法都是在做初始化。回到initGenesis，makeFullNode之后有一个遍历，遍历了两个字符串：”chaindata”, “lightchaindata”。他们的用处是用来创建数据库：12345678910// go-ethereum\node\node.gochaindb, err := stack.OpenDatabase(name, 0, 0)func (n *Node) OpenDatabase(name string, cache, handles int) (ethdb.Database, error) &#123; if n.config.DataDir == "" &#123; return ethdb.NewMemDatabase(), nil //如果路径为空，创建内存数据库，实际上就是放在内存中的一个map // go-ethereum\ethdb\memory_database.go &#125; return ethdb.NewLDBDatabase(n.config.ResolvePath(name), cache, handles)&#125; 1234567891011121314151617181920212223242526272829303132333435// go-ethereum\ethdb\database.gofunc NewLDBDatabase(file string, cache int, handles int) (*LDBDatabase, error) &#123; logger := log.New("database", file) //从init调用过来时，cache和handles都为0 //默认启动节点，cache为512，handles为0，在node.DefaultConfig配置 // Ensure we have some minimal caching and file guarantees if cache &lt; 16 &#123; cache = 16 &#125; if handles &lt; 16 &#123; handles = 16 &#125; logger.Info("Allocated cache and file handles", "cache", common.StorageSize(cache*1024*1024), "handles", handles) // Open the db and recover any potential corruptions db, err := leveldb.OpenFile(file, &amp;opt.Options&#123; OpenFilesCacheCapacity: handles, BlockCacheCapacity: cache / 2 * opt.MiB, WriteBuffer: cache / 4 * opt.MiB, // Two of these are used internally Filter: filter.NewBloomFilter(10), &#125;) if _, corrupted := err.(*errors.ErrCorrupted); corrupted &#123; db, err = leveldb.RecoverFile(file, nil) &#125; // (Re)check for errors and abort if opening of the db failed if err != nil &#123; return nil, err &#125; return &amp;LDBDatabase&#123; fn: file, db: db, log: logger, &#125;, nil&#125; 这里使用的levelDB数据库，关于这个数据库的介绍与使用见这里。逻辑很简单就是在指定位置创建levelDB数据库。数据库创建完成后，回到initGenesis，接下来开始写内容：123456789101112131415161718192021222324252627_, hash, err := core.SetupGenesisBlock(chaindb, genesis)// go-ethereum\core\genesis.gofunc SetupGenesisBlock(db ethdb.Database, genesis *Genesis) (*params.ChainConfig, common.Hash, error) &#123; return SetupGenesisBlockWithOverride(db, genesis, nil)&#125;func SetupGenesisBlockWithOverride(db ethdb.Database, genesis *Genesis, constantinopleOverride *big.Int) (*params.ChainConfig, common.Hash, error) &#123; if genesis != nil &amp;&amp; genesis.Config == nil &#123; //如果json，没有配置config部分，则退出 return params.AllEthashProtocolChanges, common.Hash&#123;&#125;, errGenesisNoConfig &#125; // Just commit the new block if there is no stored genesis block. stored := rawdb.ReadCanonicalHash(db, 0) // go-ethereum\core\rawdb\accessors_chain.go //从数据库中获取创世区块的hash if (stored == common.Hash&#123;&#125;) &#123; //如果为空，init会进入这个分支 if genesis == nil &#123; log.Info("Writing default main-net genesis block") genesis = DefaultGenesisBlock() &#125; else &#123; log.Info("Writing custom genesis block") &#125; // 写入数据库 block, err := genesis.Commit(db) return genesis.Config, block.Hash(), err &#125; .....&#125; 首先利用rawdb.ReadCanonicalHash(db, 0)或取genesis区块，由于是初始化，自然获取不到，进入下面的if分枝，首先调用了Commit(db)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// go-ethereum\core\genesis.gofunc (g *Genesis) Commit(db ethdb.Database) (*types.Block, error) &#123; block := g.ToBlock(db) if block.Number().Sign() != 0 &#123; return nil, fmt.Errorf("can't commit genesis block with number &gt; 0") &#125; // go-ethereum\core\rawdb\accessors_chain.go 写入各种信息 rawdb.WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty) rawdb.WriteBlock(db, block) rawdb.WriteReceipts(db, block.Hash(), block.NumberU64(), nil) rawdb.WriteCanonicalHash(db, block.Hash(), block.NumberU64()) rawdb.WriteHeadBlockHash(db, block.Hash()) rawdb.WriteHeadHeaderHash(db, block.Hash()) config := g.Config if config == nil &#123; config = params.AllEthashProtocolChanges &#125; rawdb.WriteChainConfig(db, block.Hash(), config) return block, nil&#125;func (g *Genesis) ToBlock(db ethdb.Database) *types.Block &#123; if db == nil &#123; //如果数据库为nil，建立一个内存数据库 db = ethdb.NewMemDatabase() &#125; statedb, _ := state.New(common.Hash&#123;&#125;, state.NewDatabase(db)) // go-ethereum\core\state\statedb.go // go-ethereum\core\state\database.go //state.New：根据给定的Tried创建一个新的状态() //state.NewDatabase：创建一个内存数据库 for addr, account := range g.Alloc &#123; //遍历json文件中的alloc配置 statedb.AddBalance(addr, account.Balance) statedb.SetCode(addr, account.Code) statedb.SetNonce(addr, account.Nonce) for key, value := range account.Storage &#123; statedb.SetState(addr, key, value) &#125; &#125; root := statedb.IntermediateRoot(false) head := &amp;types.Header&#123; //go-ethereum\core\types\block.go 创建区块头 Number: new(big.Int).SetUint64(g.Number), Nonce: types.EncodeNonce(g.Nonce), Time: new(big.Int).SetUint64(g.Timestamp), ParentHash: g.ParentHash, Extra: g.ExtraData, GasLimit: g.GasLimit, GasUsed: g.GasUsed, Difficulty: g.Difficulty, MixDigest: g.Mixhash, Coinbase: g.Coinbase, Root: root, &#125; if g.GasLimit == 0 &#123; head.GasLimit = params.GenesisGasLimit //默认为4712388 go-ethereum\params\protocol_params.go &#125; if g.Difficulty == nil &#123; head.Difficulty = params.GenesisDifficulty //默认为131072 &#125; statedb.Commit(false) statedb.Database().TrieDB().Commit(root, true) return types.NewBlock(head, nil, nil, nil)//创建一个新的区块 go-ethereum\core\types\block.go //每个区块有四部分内容，区块头，交易列表，叔块，收据&#125; Commit方法中首先调用了ToBlock，在这里创建了一个实例化的区块对象并返回，之后再Commit中写入各种信息到数据库中，我们以总难度为例，看它是如何写入的：1234567891011rawdb.WriteTd(db, block.Hash(), block.NumberU64(), g.Difficulty)func WriteTd(db DatabaseWriter, hash common.Hash, number uint64, td *big.Int) &#123; data, err := rlp.EncodeToBytes(td) if err != nil &#123; log.Crit("Failed to RLP encode block total difficulty", "err", err) &#125; if err := db.Put(headerTDKey(number, hash), data); err != nil &#123; log.Crit("Failed to store block total difficulty", "err", err) &#125;&#125; 首先WriteTd接收四个参数，分别是数据库的实例，区块hash，区块编号，难度值。之后将难度值进行RLP编码，然后调用db.Put()写入数据库，写入的键是headerTDKey(number, hash)，值就是编码过得数据。在commit的最后，写入所有数据后，返回了区块实例，然后回到initGenesis方法，最终返回了错误信息和区块hash。到此init的流程就结束了。创世区块的内容也被写入了数据库。]]></content>
      <categories>
        <category>go-ethereum源码学习</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>以太坊</tag>
        <tag>go-ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-ethereum编译流程简单学习]]></title>
    <url>%2F2019%2F02%2F21%2Fgo-ethereum%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[go-ethereum源码学习：源码编译流程 一般，在根目录下执行make geth 或者 make all编译go-ethereum。前者仅编译go-ethereum主程序，后者编译所有模块。详见go-ethereum的README 以make geth为例，进入go-ethereum根目录下，打开Makefile文件，执行的逻辑是1234geth: build/env.sh go run build/ci.go install ./cmd/geth @echo "Done building." @echo "Run \"$(GOBIN)/geth\" to launch geth." 可见直接执行了build/env.sh脚本，传入的参数为go run build/ci.go install ./cmd/geth 进入这个脚本文件，签名若干行都是在进行目录和环境设置，只有最后一行起到编译作用1exec "$@" exec指执行后面的跟的命令，$@是一个变量，存储着传给这个脚本的所有参数，这里的参数就是上面说的go run build/ci.go install ./cmd/geth ./cmd/geth，这就是go的编译命令，他编译运行的是build/ci.go文件，顺便还传入了参数install ./cmd/geth 首先在这个文件开头，我们可以知道这也是一个CLI程序，和我们编译生成的geth类似，在开头列出了一些命令的格式，如第一行就是我们流程中将要执行的1234Available commands are: install [ -arch architecture ] [ -cc compiler ] [ packages... ] ... 我们所要执行的就是 install ./cmd/geth，没有任何附加参数。 先从main函数开始，在这里的switch结构中，判断了第一个参数，我们这里为install，执行doInstall(os.Args[2:])，传入的参数自然为./cmd/geth。doInstall这个方法也比较简单，首先，利用flag进行参数解析，然后判断了go的版本后，最后根据需求拼凑编译指令。这一部分关键步骤注释见这里]]></content>
      <categories>
        <category>go-ethereum源码学习</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>以太坊</tag>
        <tag>go-ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go的CLI程序开发]]></title>
    <url>%2F2019%2F02%2F21%2Fgo%E7%9A%84CLI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[CLI(command-line interface)就是命令行界面，我们在linux命令行中输入的一个个指令都是CLI程序，典型如tar命令，一般使用go开发一个命令行程序有以下几种方法 Arguments这个算是最基本的方法，但也是最繁琐的。主要借助os.Args，查看源码，介绍如下 12// Args hold the command-line arguments, starting with the program name.var Args []string 这里告诉我们这个数组切片保存了命令行的参数，且第一个参数程序名。这里需要注意的一点是，就算一个参数不附加，os.Args这个数组也是有一个值的，就是当前的程序，所以我们在通过len(os.Args)判断是否有额外参数时，len(os.Args)&gt;1才能说明有额外参数 既然我们可以通过这个数组获取所有参数，那么就可以通过一系列参数判断，开发出一个命令行程序，但无疑是很繁琐的，所以go标准库中提供了一个简单的库来帮助我们 flag我们先引入一个小例子 12345func main() &#123; dir := flag.String("dir","/home/user","data directory") flag.Parse() fmt.Println(*dir)&#125; 之后再命令行输入下面命令去运行，123456789101112131415161718go run example.go 输出/home/usergo run example.go -dir /etc/opt 输出/etc/optgo run in.go -h输出：Usage of .../example.exe -dir string data directory (default &quot;/home/user&quot;) go run example.go -dirs /etc输出：flag provided but not defined: -dirsUsage of .../example.exe -dir string data directory (default &quot;/home/user&quot;) 可以看出这已经是一个比较完善的命令程序，我们指定了参数名：dir，默认值：”/home/user”，以及参数解释：”data directory”。之后flag包自动帮我们解析参数，并附带了-h帮助信息，以及未定义参数的提示信息 通过上面的例子基本可以了解flag大体使用方法，首先定义一些参数，之后flag.Parse()进行解析，最后使用解析到的数据即可，关于Parse()源码如下 123func Parse() &#123; CommandLine.Parse(os.Args[1:])&#125; 可见也是用的os.Args[1:]作为输入，只不过这个包帮我们做好了匹配及错误处理而已。接下来详细学习一下用法 flag定义基本上分三大类： flag.Xxx(name,value,usage) *Xxx Xxx表示相应的数据类型，如Bool，Float64，Int，String等等，参数都是三个：名称，默认值，用法介绍。返回值1是相应类型的一个指针变量。例子如下： 1dir := flag.String("dir","/home/user","data directory") flag.XxxVar(p,name,value,usage) Xxx也是表示相应的数据类型，和上面那个一样，区别是多了一个参数，需要传入一个变量的引用，然后解析时会把值赋给这个变量，没有返回值，例子如下 12var dir stringflag.StringVar(&amp;dir,"dir","/home/user","data directory") flag.Var(value,name,usage) 当包中预定义的数据类型不能满足要求时，就需要这个方法了，第一个参数是一个引用，其类是实现flag.Value 接口，剩下的两个参数意义和上边的一样。先看一下这个接口 1234type Value interface &#123; String() string Set(string) error&#125; 基本上就是要定义存取方法，只不过存取的值都必须是string类型，举一个简单的例子 1234567891011121314151617181920212223242526272829303132type student struct &#123; name string age int64&#125;func (s *student) String()string&#123; return s.name+string(s.age)&#125;func (s *student) Set(str string)error&#123; slice:=strings.Split(str,",") if len(slice)!=2 &#123; return errors.New("bad format") &#125; i,err:=strconv.ParseInt(slice[1],10,64) if err!=nil &#123; return err &#125; s.name = slice[0] s.age = i return nil&#125;func main() &#123; var dir student flag.Var(&amp;dir,"stu","student info") flag.Parse() fmt.Println(dir.name,"+++",dir.age)&#125;//用法//go run example.go -stu wang,21 flag格式一般形式如下： 123-flag-flag = x-flag x //仅适用于非boolean类型flag 其中-和–都是允许的 flag解析会在遇到第一个非flag参数或单独的–之后停止，例 123456func main() &#123; n := flag.Int("n",0,"number") flag.Parse() fmt.Println(*n) fmt.Println(flag.NArg())&#125; 下面的命令都会由于提前停止解析得不到所要的值 123go run example.go 45 -n 1 //flag.NArg()会返回3go run example.go - -n 1 //flag.NArg()会返回3go run example.go -- -n 1 //flag.NArg()会返回2，--被当做终止符 其他方法 Arg(i int)string ， Args()[]string ， NArg()int ， NFlag()int Arg(i int)返回的是在被flag解析后，第i个剩余的参数，没有的话返回空字符串 Args()返回的是被flag解析后，剩余参数数组切片 NArg()返回的是被flag解析后，剩余参数的个数 NFlag()返回的是接收到的flag参数个数（并不是定义的个数） 12345678910111213n := flag.Int("n",0,"number")flag.Parse()fmt.Println(n)fmt.Println(flag.Arg(1))//输入&gt;go run example.go -n 1 454 555，返回555 //输入&gt;go run example.go -n 1 454 ，返回空 fmt.Println(flag.Args())//输入&gt;go run example.go -n 1 454 555，返回[454,555]fmt.Println(flag.NArg())//输入&gt;go run example.go -n 1 454 555,返回2fmt.Println(flag.NFlag())//输入&gt;go run example.go -n 1 454 555，返回1 //输入&gt;go run example.go 454 555，返回0 flag.Parsed()bool 判断参数是否解析过 Set(name, value string) error 给指定的flag赋值 flag.Usage 库里已经帮我们自动生成了一套帮助信息，可以使用-h或-help查看，另外我们也可以自己定制，重写Usage例 123 flag.Usage = func() &#123; fmt.Println("hello world")&#125; 另外我们也可以看一下源码，原来的帮助信息是怎么生成的 1234var Usage = func() &#123; fmt.Fprintf(CommandLine.Output(), "Usage of %s:\n", os.Args[0]) PrintDefaults()&#125; 可见，先是打印了os.Args[0]，也就是程序信息，之后调用了PrintDefaults()，打印了所有flag的信息 urfave/cli其实官方给出的flag已能满足大部分要求，如果有更复杂的需要，可以借助这个强大的第三方包urfave/cli 安装与导包1go get github.com/urfave/cli 123import ( "gopkg.in/urfave/cli.v1") 简单使用该包的github主页有详细的使用说明，这里就不一一赘述了，只简单说一下常用的使用流程 实例化App对象 1app := cli.NewApp() 配置App信息 123456789101112131415161718192021222324252627282930313233343536//这个包可以配置丰富的App描述信息，如名称，版本号，作者，版权信息，程序简介等app.Name = "HelloWorld"app.Version = "1.0.0"app.Authors = []cli.Author&#123; cli.Author&#123; Name: "Tom", Email: "Tom@example.com", &#125;,&#125;app.Copyright = "(c) 1999 Serious Enterprise"app.Usage = "greet"app.UsageText = "Example program"//输入go run example.go -h后显示如下/*NAME: HelloWorld - greetUSAGE: Example programVERSION: 1.0.0AUTHOR: Tom &lt;Tom@example.com&gt;COMMANDS: help, h Shows a list of commands or help for one commandGLOBAL OPTIONS: --help, -h show help --version, -v print the versionCOPYRIGHT: (c) 1999 Serious Enterprise*/ 定义程序执行逻辑 这里是指程序运行的逻辑。主要是配置app.Action，例：12345app.Action = func(c *cli.Context) &#123; fmt.Println("hello world") &#125;//go run example.go //输出hello world 当然我们也可以不在这里定义主程序逻辑，在这里定义的一个好处是cli.Context携带了许多有用的上下文环境变量供我们使用，后面可以见到。 app.Action是执行程序时执行的逻辑，我们也可以定义在程序执行前后所要插入的逻辑，定义app.Before与app.After即可，例123456789101112131415161718192021222324func main() &#123; app := cli.NewApp() app.Before = func(context *cli.Context) error &#123; fmt.Println("before hello world") return nil; &#125; app.Action = func(c *cli.Context) &#123; fmt.Println("hello world") &#125; app.After = func(context *cli.Context) error &#123; fmt.Println("after hello world") return nil; &#125; err := app.Run(os.Args) if err != nil &#123; log.Fatal(err) &#125;&#125;//执行go run example.go/* 输出：before hello worldhello worldafter hello world*/ 注意：如果app.Before返回的error不为空，app.Action的内容将不会执行，而不管app.Action与app.Before中是否有错误发生，app.After的内容都会执行，app.After可用于收尾工作。 定义flag 这里的flag概念和上文中go的标准包中flag类似，直接看一个例子：12345678910111213141516171819202122func main() &#123; app := cli.NewApp() app.Flags = []cli.Flag&#123; cli.StringFlag&#123; Name:"path", Value:"/home/", Usage:"setting path", &#125;, &#125; app.Action = func(c *cli.Context) &#123; fmt.Println(c.String("path")) &#125; err := app.Run(os.Args) if err != nil &#123; log.Fatal("aaa",err) &#125;&#125;//输入go run example.go -path /home/base//输出：/home/base//输入go run example.go//输出：/home/ 定义起来很简单，关键几个要素就是Name和Value，取值时使用cli.Context提供的对应取值方法即可。包内预定义了许多种类型的flag，基本涵盖了所有基本类型，详见这里 另外在取值时，除了调用如c.Int(),c.String()之类的方法，还可以在定义flag时直接绑定到某些变量上，如：123456var age intcli.IntFlag&#123; Name:"age", Value:100, Destination:&amp;age,&#125; 另外，还可以配置flag的简写或别名，只需在定义Name时定义多个名称，中间用逗号隔开即可，例：123456cli.IntFlag&#123; Name:"age,a,ege", Value:100, Destination:&amp;age,&#125;,//-age -a -ege 都是有效的 配置子命令 如git push …中push就是一个子命令，这个包为我们提供了便捷定义子命令及其动作的方法12345678910111213app.Commands = []cli.Command&#123; &#123; Name: "push", Aliases: []string&#123;"p"&#125;, Usage: "push a file to the server", Action: func(c *cli.Context) error &#123; fmt.Println("push flie: ", c.Args().First())//c.Args().First()取命令后的第一个参数 return nil &#125;, &#125;, &#125;//执行go run example.go push test.txt//输出：push flie: test.txt 用法很简单，指定命名名，别名用法，以及相应动作即可。另外子命令可以像它的一个程序一样，有自己flag，Before，After，甚至是自己的子命令，使用Subcommands定义 注意，如果即定义了app的action，又定义了子命令的action，同一时间只能执行一个，如调用子命令时，app的action就不会执行 启动程序 所有配置都配置完成后，就需要启动程序，不然是不会生效的1234err := app.Run(os.Args)if err != nil &#123; log.Fatal("aaa",err)&#125; 最后给出一个详细例子，这是给出的，基本上涵盖了所有配置要点:例子]]></content>
      <categories>
        <category>go语言学习笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[一切都从Hello World开始！ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
